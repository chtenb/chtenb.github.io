<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>LUSH</title>
  <style>code {
  white-space: pre-wrap;
}

span.smallcaps {
  font-variant: small-caps;
}

div.columns {
  gap: min(4vw, 1.5em);
  display: flex;
}

div.column {
  flex: auto;
  overflow-x: auto;
}

div.hanging-indent {
  text-indent: -1.5em;
  margin-left: 1.5em;
}

ul.task-list[class] {
  list-style: none;
}

ul.task-list li input[type="checkbox"] {
  font-size: inherit;
  vertical-align: middle;
  width: .8em;
  margin: 0 .8em .2em -1.6em;
}

.display.math {
  text-align: center;
  margin: .5rem auto;
  display: block;
}

pre > code.sourceCode {
  white-space: pre;
  position: relative;
}

pre > code.sourceCode > span {
  line-height: 1.25;
}

pre > code.sourceCode > span:empty {
  height: 1.2em;
}

.sourceCode {
  overflow: visible;
}

code.sourceCode > span {
  color: inherit;
  -webkit-text-decoration: inherit;
  text-decoration: inherit;
}

div.sourceCode {
  margin: 1em 0;
}

pre.sourceCode {
  margin: 0;
}

@media screen {
  div.sourceCode {
    overflow: auto;
  }
}

@media print {
  pre > code.sourceCode {
    white-space: pre-wrap;
  }

  pre > code.sourceCode > span {
    text-indent: -5em;
    padding-left: 5em;
  }
}

pre.numberSource code {
  counter-reset: source-line 0;
}

pre.numberSource code > span {
  counter-increment: source-line;
  position: relative;
  left: -4em;
}

pre.numberSource code > span > a:first-child:before {
  content: counter(source-line);
  text-align: right;
  vertical-align: baseline;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  -khtml-user-select: none;
  color: #005661;
  background-color: #fefaf2;
  border: none;
  width: 4em;
  padding: 0 4px;
  display: inline-block;
  position: relative;
  left: -1em;
}

pre.numberSource {
  border-left: 1px solid #005661;
  margin-left: 3em;
  padding-left: 4px;
}

div.sourceCode {
  color: #005661;
  background-color: #fefaf2;
}

@media screen {
  pre > code.sourceCode > span > a:first-child:before {
    text-decoration: underline;
  }
}

code span {
  color: #005661;
}

code span.al {
  color: #e64100;
}

code span.an {
  color: #00bdd6;
}

code span.at {
  color: #b3694d;
}

code span.bn {
  color: #e64100;
}

code span.bu {
  color: #fa8900;
}

code span.cf {
  color: #ff5792;
  font-weight: bold;
}

code span.ch, code span.cn {
  color: #e5164a;
}

code span.co {
  color: #8ca6a6;
  font-style: italic;
}

code span.cv {
  color: #8ca6a6;
}

code span.do {
  color: #8ca6a6;
  font-style: italic;
}

code span.dt {
  color: #fa8900;
}

code span.dv, code span.er {
  color: #e64100;
}

code span.ex {
  color: #00bdd6;
}

code span.fl {
  color: #0094f0;
}

code span.fu {
  color: #0095a8;
}

code span.im {
  color: #00bdd6;
}

code span.in {
  color: #8ca6a6;
}

code span.kw {
  color: #ff5792;
  font-weight: bold;
}

code span.op {
  color: #0094f0;
}

code span.ot {
  color: #005661;
}

code span.pp {
  color: #0095a8;
}

code span.re {
  color: #00bdd6;
}

code span.sc {
  color: #e5164a;
}

code span.ss {
  color: #00bdd6;
}

code span.st {
  color: #00b368;
}

code span.va, code span.vs {
  color: #004d57;
}

code span.wa {
  color: #e64100;
}
</style>
  <style type="text/css"></style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">LUSH</h1>
</header>
<div id="content">
<p>Lispy Unix SHell</p>
<p>Design in one sentence: type CLI pipelines with POSIX syntax, but any
higher order pipeline logic is done using s-expressions. Interactive
features are configured with lisp code.</p>
<h2 id="program-model"><a class="anchor" href="#program-model"></a>Program
model</h2>
<p><strong>Primary Ways a Program Receives Input</strong></p>
<ol type="1">
<li>Command-line arguments (argv)
<ul>
<li>Passed at exec time by the parent process.</li>
</ul></li>
<li>Environment variables (envp)
<ul>
<li>Also passed at exec time.</li>
</ul></li>
<li>Initial file descriptors
<ul>
<li>Includes standard FDs: stdin (0), stdout (1), stderr (2)</li>
<li>May include additional FDs from parent (e.g., pipes, sockets,
inherited resources)</li>
</ul></li>
<li>Current working dir</li>
<li>Filesystem (readable or discoverable)
<ul>
<li>Can read config files, device files, /proc, etc.</li>
<li>Includes memory-mapped files, shm_open, etc.</li>
<li>Requires knowing where to look (e.g., $HOME/.config/foo,
/etc/foo.conf)</li>
</ul></li>
<li>Signals (asynchronous control flow)
<ul>
<li>Delivered at any time during execution.</li>
<li>Can only carry limited information (signal number, sometimes a bit
more via siginfo_t)</li>
</ul></li>
</ol>
<p>We consider channels 4, 5 and 6 side effects, to be used only if they
are required to complete a programs objective. Side effects should be
documented properly when sharing programs with others.</p>
<p>We consider channels 1, 2 and 3 part of the normal program flow, and
built our language around these.</p>
<p><strong>Main Concepts</strong></p>
<p>A <em>program</em> models a recipe for work being done on the
computer. A program has <em>parameters</em>, <em>I/O streams</em> and an
<em>environment</em>. The parameters are explicitly specified by caller
of a program, whereas the I/O streams and environment variables are
inherited implicitly.</p>
<p>A <em>command</em> is a program supplied with a list of arguments as
the program’s parameters. An <em>invocation</em> is the execution
instance of a command. An invocation receives its environment variables
as a copy of its parent’s, possibly with invocation-specific
modifications. An invocation receives its standard file descriptors as a
copy of its parent’s, possibly with invocation-specific
redirections.</p>
<p>The <em>scope</em> of an invocation is of the set of available
programs to be called. This does not include running a program
explicitly via it’s absolute path (which is considered a filesystem
interaction, and thus a side effect). Invocations inherit scopes
automatically from the parent invocation, in the same manner as the
environment .</p>
<p>The <em>variables</em> of an invocation is the list of environment
variables inherited from the parent invocation. The scope and variables
together form the <em>environment</em> of the invocation.</p>
<p>The <em>return code</em> of an invocation is a byte that indicates
how the execution went. A return code of 0 signals an uneventful
execution, while any other values have program specific meanings and
usually indicate something went wrong.</p>
<p>A <em>macro</em> is a callable entity that is not a program.</p>
<p><strong>Data</strong></p>
<p>There are two types of data values: lists and constants, each defined
as usual in Lisp languages. The only supported constant is currently the
string. A constant is conceptually the same as a program that takes no
arguments and writes that value to stdout.</p>
<p>Programs communicate data by default through stdin/stdout and
arguments. The args list is a list of the argument values supplied to
the command. The stdin is a readable stream of values, whereas the
stdout is a writeable stream of values. The stderr is normally used for
communicating with the user, such a log messaging.</p>
<p><strong>Syntax</strong></p>
<p>Commands are invoked like</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="sc">&lt;</span>program<span class="sc">&gt;</span> [arg1 [arg2 ...]])</span></code></pre></div>
<p>Program are definited like</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(program args <span class="sc">&lt;</span>command<span class="sc">&gt;</span>)</span></code></pre></div>
<p>Programs are installed (named) into the current scope like</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(install name <span class="sc">&lt;</span>program<span class="sc">&gt;</span>)</span></code></pre></div>
<p>There are two macros to write data: <code>out</code> and
<code>err</code>. They both take any number of values as argument and
write them to stdout and stderr respectively.</p>
<p><strong>Evaluation</strong></p>
<p>When a command is invoked, its arguments are first evaluated from
left to right.</p>
<ul>
<li>When an argument is a command invocation, it is executed and its
stdout is captured as used as argument values. Since stdout is a stream
of values, this can result in more than one argument being passed.</li>
<li>When an argument is a constant, it evaluates to itself. Note that
this is the same as invoking a parameterless program writing that value
to stdout.</li>
<li>When an argument is a macro invocation, it follows macro-specific
rules for evaluation.</li>
</ul>
<h2 id="example-programs"><a class="anchor" href="#example-programs"></a>Example
programs</h2>
<p>Comments start with <code>#</code>. At the top level, the outermost
parameters are optional if the command is typed on one line.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>program <span class="fu">args</span> (out <span class="st">&quot;hello world&quot;</span>) <span class="co"># A program that writes hello world to stdout</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;hello world&quot;</span> <span class="co"># Also a program that writes hello world to stdout</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>install <span class="fu">l</span> (program <span class="fu">args</span> (ls <span class="sc">-</span><span class="fu">al</span> (args <span class="sc">|</span> expand))) <span class="co"># Makes alias of the `ls -al` command available in the current scope</span></span></code></pre></div>
<!--

### Output capture
There are three ways to capture output as a byte sequence and rebind this an argument to another program.

*`(cmd)`*: Evaluates cmd, sends stderr to parent, and captures stdout. If return code is nonzero, evaluation of parent is aborted.
*`?(cmd)`*: Evaluates cmd and captures return code as bytestring of length 1. Stdout and stderr are sent to parent.
*`$(cmd)`*: Evaluates cmd and captures triple (stdout stderr returncode).

The program `rc` takes one byte n as parameter and exits with return code n upon invocation.
The program `echo` takes a bytestring as argument and writes this to stdout.

```py
(program n) ≡ (program ?(rc n))
(program b) ≡ (program (echo b))
```

### Command algebra
Commands can be composed to produce more complex commands.

*`&`*: If `A` and `B` are commands, then so is `A & B`. This command first runs A passing the stdin onto A and waits for completion. Both output streams of `A` are directed to the corresponding output streams of the compound program. Then `B` is invoked in the same manner as `A`. The return code is that of B.
*`;`*: The same as `A & B` except `B` is only invoked when the return code of `A` is 0.
*`?`*: The same as `A & B` except `B` is only invoked when the return code of `A` is not 0.
*`|`*: If `A` and `B` are commands, then so is `A | B`. The command invokes both `A` and `B` (they are started in order, but will usually run concurrently). The stdin of the compound command is directed to A, the stdout of A is directed to the stdin of B. The stdout of B is directed to the stdout of the compound command. The stderr of both A and B are directed to the stderr of the compound command. The return code is the first non-zero return code of the chain.

The precedence of these operators is `&` > `?` > `|`  > `;`.

Identifiers may be bound to programs or arguments.

```py
(program (dir) (cd dir ; (ls | grep README) ? echo "No readme found"))
```

This program attempts to enter the given directory and search for a file with a name that contains "README" in it. If the directory does not exist, the program exits with the return code of `cd`. If no readme has been found, the program writes a messages to stdout.

### I/O redirections

Standard redirections are postfix macros:

```sh
(cmd > file.txt)
(cmd >> file.txt)
(cmd err> file.txt)
(cmd err>> file.txt)
(cmd < file.txt)
(cmd err>out) # points fd (file descriptor) 2 to the same file description as fd 1.
(cmd err<>out) # swaps file descriptions of fds 1 and 2.
(cmd err+>out) # points fd 2 to a pipe that writes to fd 1 and the original file description of fd 2.
```


## Wire format
A *byte* is a number between 0 and 255 (inclusive).
A *value* is a sequence of bytes that does not contain the byte 0.
A *bytestream* is a sequence of bytes (including 0-bytes) which can only be traversed once, and only in a sequential manner.


### List encoding
Lists are supported by Lush.
It also acts as a mapping by the following convention: a list entry that contains an `=` character can be treated as a key-value pair, whereby the bytestring before the first `=` is treated as key.
Lists are represented in memory by a series of bytestrings, separated by a US (Unit Separator/31/1F) byte.
Lists can be nested, where byte SI (Shift In/14/E) opens a nested list, and byte SO (Shift Out/15/F) closes it.

-->
</div>
</body>
</html>
