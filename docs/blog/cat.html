<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Category Theory</title>
  <style>code {
  white-space: pre-wrap;
}

span.smallcaps {
  font-variant: small-caps;
}

div.columns {
  gap: min(4vw, 1.5em);
  display: flex;
}

div.column {
  flex: auto;
  overflow-x: auto;
}

div.hanging-indent {
  text-indent: -1.5em;
  margin-left: 1.5em;
}

ul.task-list[class] {
  list-style: none;
}

ul.task-list li input[type="checkbox"] {
  font-size: inherit;
  vertical-align: middle;
  width: .8em;
  margin: 0 .8em .2em -1.6em;
}

.display.math {
  text-align: center;
  margin: .5rem auto;
  display: block;
}
</style>
  <style type="text/css"></style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Category Theory</h1>
</header>
<div id="content">
<p>This is an imprecise collection of notes about category theory, using
an experimental notation that mixes the traditional set-theory oriented
notation for functions with a more programming language oriented
notation.</p>
<ul>
<li><a href="#notation">Notation</a></li>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#category">Definition 1. (Category)</a></li>
<li><a href="#homsetsarrowsets">Definition 2.
(Homsets/Arrowsets)</a></li>
<li><a href="#inverses">Definition 3. (Inverses)</a></li>
<li><a href="#isomorphism">Definition 4. (Isomorphism)</a></li>
<li><a href="#functor">Definition 5. (Functor)</a></li>
<li><a href="#natural-transformations">Definition 6. (Natural
Transformations)</a></li>
<li><a href="#product-category">Definition 7. (Product
Category)</a></li>
<li><a href="#bifunctor">Definition 8. (Bifunctor)</a></li>
<li><a href="#dual-category-or-opposite-category">Definition 9. (Dual
Category or Opposite Category)</a></li>
<li><a href="#contravariant-functor">Definition 10. (Contravariant
Functor)</a></li>
<li><a href="#covariant-homfunctor">Definition 11. (Covariant
Homfunctor)</a></li>
<li><a href="#contravariant-homfunctor">Definition 12. (Contravariant
Homfunctor)</a></li>
<li><a href="#homfunctor">Definition 13. (Homfunctor)</a></li>
<li><a href="#product-and-coproduct">Definition 14. (Product and
Coproduct)</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#the-monoid-category">Example 15. (The Monoid
Category)</a></li>
<li><a href="#the-category-of-categories">Example 16. (The Category of
Categories)</a></li>
<li><a href="#the-set-category">Example 17. (The Set Category)</a></li>
<li><a href="#the-product-functor-in-set">Example 18. (The Product
Functor in Set)</a></li>
<li><a href="#the-sum-functor-in-set">Example 19. (The Sum Functor in
Set)</a></li>
<li><a href="#the-list-functor">Example 20. (The List Functor)</a></li>
<li><a href="#haskell-functor">Example 21. (Haskell Functor)</a></li>
</ul>
<h2 id="notation"><a class="anchor" href="#notation"></a>Notation</h2>
<ul>
<li>Objects are mapped using angled brackets, morphisms are mapped using
parentheses</li>
</ul>
<h2 id="definitions"><a class="anchor" href="#definitions"></a>Definitions</h2>
<section id="category" class="Definition">
<h4><a class="anchor" href="#category"></a>Definition 1. (Category)</h4>
<p>A <strong>category</strong> <code>ğ“’</code> consists of the following
components:</p>
<ol type="1">
<li><strong>Objects</strong>: Denoted by uppercase letters, e.g.,
<code>A</code>, <code>B</code>, <code>C</code>. The set of all objects
of <code>ğ“’</code> is written <code>Obj(ğ“’)</code>.</li>
<li><strong>Morphisms</strong>: Also called <em>arrows</em>. Denoted by
lowercase letters. A morphism <code>f</code> from object <code>A</code>
to object <code>B</code> is written as <code>f: A â†’ B</code>. The set of
all morphisms of <code>ğ“’</code> is written <code>Mor(ğ“’)</code> or
<code>Hom(ğ“’)</code>. Morphisms are also called
<strong>arrows</strong>.</li>
<li><strong>Composition</strong>: Given morphisms <code>f: A â†’ B</code>
and <code>g: B â†’ C</code>, their composition is another morphism,
denoted <code>g âˆ˜ f: A â†’ C</code>. The composition operator satisfies
associativity, meaning for any morphism <code>h: C â†’ D</code> it holds
true that <code>(h âˆ˜ g) âˆ˜ f = h âˆ˜ (g âˆ˜ f)</code>. Alternatively,
composition can be written using forward composition,
<code>f â–¹ g: A â†’ C</code>.</li>
<li><strong>Identity morphism</strong>: For each object <code>A</code>,
there exists an identity morphism <code>id&lt;A&gt;</code> such that for
any morphism <code>f: A â†’ B</code>, we have
<code>f â–¹ id&lt;B&gt; = f = id&lt;A&gt; â–¹ f</code>.</li>
</ol>
</section>
<section id="homsetsarrowsets" class="Definition">
<h4><a class="anchor" href="#homsetsarrowsets"></a>Definition 2.
(Homsets/Arrowsets)</h4>
<p>For two objects <code>A,B</code> in a category <code>ğ“’</code>, the
set of morphisms from <code>A</code> to <code>B</code> is called the
homset, or arrowset, from <code>A</code> to <code>B</code>. We denote
this set by <code>Aâ†’B</code>. In other words, the notation
<code>m âˆˆ Aâ†’B</code> is equivalent to <code>m: A â†’ B</code>.</p>
</section>
<section id="inverses" class="Definition">
<h4><a class="anchor" href="#inverses"></a>Definition 3. (Inverses)</h4>
<p>Given a category <code>ğ“’</code> and a morphism
<code>f: A â†’ B</code>.</p>
<ul>
<li>Any morphism <code>g: B â†’ A</code> is called a
<strong>pre-inverse</strong> of <code>f</code> if and only if
<code>g â–¹ f = id&lt;B&gt;</code>.</li>
<li>Any morphism <code>g: B â†’ A</code> is called a
<strong>post-inverse</strong> of <code>f</code> if and only if
<code>f â–¹ g = id&lt;A&gt;</code>.</li>
<li>Any morphism <code>g: B â†’ A</code> is called an
<strong>inverse</strong> of <code>f</code> if and only if it is both a
pre-inverse and a post-inverse to <code>f</code>.</li>
</ul>
</section>
<section id="isomorphism" class="Definition">
<h4><a class="anchor" href="#isomorphism"></a>Definition 4.
(Isomorphism)</h4>
<p>Given a category <code>ğ“’</code>, a morphism <code>f: A â†’ B</code> is
called an <strong>isomorphism</strong> if there exists an inverse
morphism to <code>f</code>.</p>
</section>
<section id="functor" class="Definition">
<h4><a class="anchor" href="#functor"></a>Definition 5. (Functor)</h4>
<p>A <strong>functor</strong> <code>F</code> from category
<code>ğ“’</code> to category <code>ğ““</code>, denoted
<code>F: ğ“’ â†’ ğ““</code>, consists of two mappings:</p>
<ol type="1">
<li><strong>On Objects</strong>: For each object <code>A</code> in
<code>ğ“’</code>, there is an object <code>F&lt;A&gt;</code> in
<code>ğ““</code>.</li>
<li><strong>On Morphisms</strong>: For each morphism
<code>f: A â†’ B</code> in <code>ğ“’</code>, there is a morphism
<code>F(f): F&lt;A&gt; â†’ F&lt;B&gt;</code> in <code>ğ““</code> such that:
<ul>
<li><strong>Preserves Identity</strong>:
<code>F(id&lt;A&gt;) = id&lt;F&lt;A&gt;&gt;</code>.</li>
<li><strong>Preserves Composition</strong>: For morphisms
<code>f: A â†’ B</code> and <code>g: B â†’ C</code> in <code>C</code>,
<code>F&lt;g âˆ˜ f&gt; = F&lt;g&gt; âˆ˜ F&lt;f&gt;</code>.</li>
</ul></li>
</ol>
<p>If <code>ğ“’</code> and <code>ğ““</code> are the same category,
<code>F</code> is called an <strong>endofunctor</strong>.</p>
</section>
<section id="natural-transformations" class="Definition">
<h4><a class="anchor" href="#natural-transformations"></a>Definition 6.
(Natural Transformations)</h4>
<p>Natural transformations are denoted with greek letters. Given
functors <code>F, G: ğ“’ â†’ ğ““</code>, a natural transformation
<code>Î·: F â‡’ G</code> assigns to each object <code>A</code> in
<code>ğ“’</code> a morphism
<code>Î·&lt;A&gt;: F&lt;A&gt; â†’ G&lt;A&gt;</code> in <code>ğ““</code> such
that for every morphism <code>m: A â†’ B</code> in <code>ğ“’</code>, the
following equation holds
<code>Î·&lt;A&gt; â–¹ G(m) = F(m) â–¹ Î·&lt;B&gt;</code>. This is often
described visually as that this square â€˜commutesâ€™:</p>
<pre><code>F&lt;A&gt; ---F(m)---&gt; F&lt;B&gt;
 |                |
Î·&lt;A&gt;             Î·&lt;B&gt;
 |                |
 v                v
G&lt;A&gt; ---G(m)---&gt; G&lt;B&gt;</code></pre>
<p>If <code>Î·&lt;A&gt;</code> is an isomorphism in <code>ğ““</code> for
every <code>A</code> in <code>ğ“’</code>, <code>Î·</code> is called a
<em>natural isomorphism</em>.</p>
</section>
<section id="product-category" class="Definition">
<h4><a class="anchor" href="#product-category"></a>Definition 7.
(Product Category)</h4>
<p>Given two categories <code>ğ“’</code> and <code>ğ““</code>, the product
category <code>ğ“’ â¨¯ ğ““</code> is defined as follows.</p>
<ol type="1">
<li><strong>Objects</strong>:
<code>Obj(ğ“’â¨¯ğ““) = Obj(ğ“’) â¨¯ Obj(ğ““)</code></li>
<li><strong>Morphisms</strong>: For every two objects <code>(A,B)</code>
and <code>(C,D)</code>, â€ƒ<code>(A,B)â†’(C,D) = Aâ†’C â¨¯ Bâ†’D</code></li>
<li><strong>Composition</strong>: For every two morphisms
<code>(f,g)</code> and <code>(h,i)</code>,
â€ƒ<code>(f,g) â–¹ (h,i) = (f â–¹ h, g â–¹ i)</code></li>
<li><strong>Identity morphisms</strong>: For every object
<code>(A,B)</code>,
â€ƒ<code>id&lt;A,B&gt; = (id&lt;A&gt;, id&lt;A&gt;)</code></li>
</ol>
<p>This forms a category.</p>
<p><em>Proof.</em></p>
<p>(Associativity) For any morphisms <code>(f, f&#39;)</code>,
<code>(g, g&#39;)</code>, and <code>(h, h&#39;)</code> in
<code>ğ“’ â¨¯ ğ““</code>,</p>
<pre><code>((f, f&#39;) â–¹ (g, g&#39;)) â–¹ (h, h&#39;) = (f, f&#39;) â–¹ ((g, g&#39;) â–¹ (h, h&#39;)).
((f, f&#39;) â–¹ (g, g&#39;)) â–¹ (h, h&#39;) = (f â–¹ g, f&#39; â–¹ g&#39;) â–¹ (h, h&#39;)     (definition composition)
                              = ((f â–¹ g) â–¹ h, (f&#39; â–¹ g&#39;) â–¹ h&#39;)  (definition composition)
(f, f&#39;) â–¹ ((g, g&#39;) â–¹ (h, h&#39;)) = (f â–¹ (g â–¹ h), f&#39; â–¹ (g&#39; â–¹ h&#39;))  (definition composition)
                              = ((f â–¹ g) â–¹ h, (f&#39; â–¹ g&#39;) â–¹ h&#39;)  (associativity composition)</code></pre>
<p>(Identity) For any object <code>(A, B)</code> in <code>ğ“’ â¨¯ ğ““</code>
and any morphism <code>(f, f&#39;)</code> coming into <code>(A, B)</code>
and any morphism <code>(g, g&#39;)</code> going out of
<code>(A, B)</code>,</p>
<pre><code>(f, f&#39;) â–¹ id&lt;A,B&gt; = (f, f&#39;) â–¹ (id&lt;A&gt;, id&lt;B&gt;) = (f â–¹ id&lt;A&gt;, f&#39; â–¹ id&lt;B&gt;) = (f, f&#39;)
id&lt;A,B&gt; â–¹ (g, g&#39;) = (id&lt;A&gt;, id&lt;B&gt;) â–¹ (g, g&#39;) = (id&lt;A&gt; â–¹ g, id&lt;B&gt; â–¹ g&#39;) = (g, g&#39;)</code></pre>
<p>âˆ</p>
</section>
<section id="bifunctor" class="Definition">
<h4><a class="anchor" href="#bifunctor"></a>Definition 8.
(Bifunctor)</h4>
<p>Given three categories <code>ğ“’</code>, <code>ğ““</code> and
<code>ğ“”</code>, a functor <code>F: ğ“’ â¨¯ ğ““ â†’ ğ“”</code> is called a
<em>bifunctor</em>.</p>
</section>
<section id="dual-category-or-opposite-category" class="Definition">
<h4><a class="anchor" href="#dual-category-or-opposite-category"></a>Definition
9. (Dual Category or Opposite Category)</h4>
<p>Every category <code>ğ“’</code> has an opposite category, denoted
<code>ğ“’â»</code>, which has the same objects as <code>ğ“’</code>, but has
the arrows reversed.</p>
<ol type="1">
<li><strong>Objects</strong>: every object <code>A</code> in
<code>ğ“’â»</code> is an object in <code>ğ“’</code></li>
<li><strong>Morphisms</strong>: a morphism <code>fâ»: A â†’ B</code> in
<code>ğ“’â»</code> is a morphism <code>f: B â†’ A</code> in <code>ğ“’</code>.
Composition <code>â–¹â»</code> between <code>fâ»</code> and
<code>gâ»: B â†’ C</code> is defined <code>fâ» â–¹â» gâ» = (gâ–¹f)â»</code>.</li>
</ol>
</section>
<section id="contravariant-functor" class="Definition">
<h4><a class="anchor" href="#contravariant-functor"></a>Definition 10.
(Contravariant Functor)</h4>
<p>Given categories <code>ğ“’</code> and <code>ğ““</code>, a functor
<code>F: ğ“’â» â†’ ğ““</code> is called a <em>contravariant functor</em>.</p>
</section>
<section id="covariant-homfunctor" class="Definition">
<h4><a class="anchor" href="#covariant-homfunctor"></a>Definition 11.
(Covariant Homfunctor)</h4>
<p>For a fixed object <code>A</code> in a category <code>ğ“’</code>, the
covariant Homfunctor (or covariant arrow functor) on <code>A</code>,
<code>Aâ†’: ğ“’ â†’ Set</code>, is defined as follows.</p>
<ol type="1">
<li><strong>On Objects</strong>: For each object <code>B</code> in
<code>ğ“’</code>, <code>Aâ†’&lt;B&gt; = Aâ†’B</code>.</li>
<li><strong>On Morphisms</strong>: Each morphism <code>f: B â†’ C</code>
in <code>ğ“’</code>, is mapped to a function between homsets
<code>Aâ†’(f): (Aâ†’B) â†’ (Aâ†’C)</code>, <code>m â†¦ m â–¹ f</code>.</li>
</ol>
</section>
<section id="contravariant-homfunctor" class="Definition">
<h4><a class="anchor" href="#contravariant-homfunctor"></a>Definition
12. (Contravariant Homfunctor)</h4>
<p>For a fixed object <code>A</code> in a category <code>ğ“’</code>, the
contravariant Homfunctor (or contravariant arrow functor) on
<code>A</code>, <code>â†’A: ğ“’ â†’ Set</code>, is defined as follows.</p>
<ol type="1">
<li><strong>On Objects</strong>: For each object <code>B</code> in
<code>ğ“’</code>, <code>â†’A&lt;B&gt; = Bâ†’A</code>.</li>
<li><strong>On Morphisms</strong>: Each morphism <code>f: B â†’ C</code>
in <code>ğ“’</code>, is mapped to a function between homsets
<code>Aâ†’(f): (Câ†’A) â†’ (Bâ†’A)</code>, <code>m â†¦ f â–¹ m</code>.</li>
</ol>
</section>
<section id="homfunctor" class="Definition">
<h4><a class="anchor" href="#homfunctor"></a>Definition 13.
(Homfunctor)</h4>
<p>For a category <code>ğ“’</code>, itâ€™s Homfunctor (or <em>arrow
functor</em>) <code>â†’: ğ“’â» Ã— ğ“’ â†’ Set</code> is defined as follows.</p>
<ol type="1">
<li><strong>On Objects</strong>: For each object
<code>&lt;Aâ‚,Aâ‚‚&gt;</code> in <code>ğ“’â» Ã— ğ“’</code>,
<code>â†’&lt;Aâ‚,Aâ‚‚&gt; = Aâ‚â†’Aâ‚‚</code>.</li>
<li><strong>On Morphisms</strong>: Each morphism
<code>(fâ‚â»,fâ‚‚): &lt;Aâ‚,Aâ‚‚&gt; â†’ &lt;Bâ‚,Bâ‚‚&gt;</code> in
<code>ğ“’â» Ã— ğ“’</code>, is mapped to a function between homsets,
<code>â†’(fâ‚â»,fâ‚‚): (Aâ‚â†’Aâ‚‚) â†’ (Bâ‚â†’Bâ‚‚)</code>,
<code>m â†¦ fâ‚ â–¹ m â–¹ fâ‚‚</code>.</li>
</ol>
<p><em>Proof.</em></p>
<pre><code>i) Prove that â†’(id&lt;Aâ‚,Aâ‚‚&gt;) = id(â†’&lt;Aâ‚,Aâ‚‚&gt;).

â†’(id&lt;Aâ‚,Aâ‚‚&gt;) 
 = â†’(id&lt;Aâ‚&gt;,id&lt;Aâ‚‚&gt;)                         (def prod cat)
 = (m: Aâ‚ â†’ Aâ‚‚) â†¦ id&lt;Aâ‚&gt; â–¹ m â–¹ id&lt;Aâ‚‚&gt;     (def hom functor)
 = (m: Aâ‚ â†’ Aâ‚‚) â†¦ m                        (def id)
 = id&lt;Aâ‚â†’Aâ‚‚&gt;                                (def id in Set)
 = id(â†’&lt;Aâ‚,Aâ‚‚&gt;)                             (def hom functor)

ii) Let (fâ‚â»,fâ‚‚) : &lt;Aâ‚,Aâ‚‚&gt; â†’ &lt;Bâ‚,Bâ‚‚&gt; and (gâ‚â»,gâ‚‚) : &lt;Bâ‚,Bâ‚‚&gt; â†’ &lt;Câ‚,Câ‚‚&gt; two morphisms in Câ» Ã— C. Prove that â†’((fâ‚â»,fâ‚‚) â–¹ (gâ‚â»,gâ‚‚)) = â†’(fâ‚â»,fâ‚‚) â–¹ â†’(gâ‚â»,gâ‚‚).

â†’((fâ‚â»,fâ‚‚) â–¹ (gâ‚â»,gâ‚‚)) 
 = â†’(fâ‚â»â–¹â»gâ‚â», fâ‚‚â–¹gâ‚‚)                                  (def prod cat)
 = â†’((gâ‚â–¹fâ‚)â», fâ‚‚â–¹gâ‚‚)                                  (def op cat)
 = (m:Aâ‚â†’Aâ‚‚) â†¦ (gâ‚ â–¹ fâ‚) â–¹ m â–¹ (fâ‚‚ â–¹ gâ‚‚)             (def hom functor)
 = (m:Aâ‚â†’Aâ‚‚) â†¦ gâ‚ â–¹ (fâ‚ â–¹ m â–¹ fâ‚‚) â–¹ gâ‚‚               (assoc)
 = (m:Aâ‚â†’Aâ‚‚) â†¦ gâ‚ â–¹ (n â†¦ fâ‚ â–¹ n â–¹ fâ‚‚)(m) â–¹ gâ‚‚       (eta expansion)
 = (m:Aâ‚â†’Aâ‚‚) â†¦ gâ‚ â–¹ â†’(fâ‚â»,fâ‚‚)(m) â–¹ gâ‚‚                 (def hom functor)
 = (m:Aâ‚â†’Aâ‚‚) â†¦ (n â†¦ gâ‚ â–¹ n â–¹ gâ‚‚)(â†’(fâ‚â»,fâ‚‚)(m))        (eta expansion)
 = (m:Aâ‚â†’Aâ‚‚) â†¦ (â†’(fâ‚â»,fâ‚‚) â–¹ (n â†¦ gâ‚ â–¹ n â–¹ gâ‚‚))(m)    (def function composition)
 = (m:Aâ‚â†’Aâ‚‚) â†¦ (â†’(fâ‚â»,fâ‚‚) â–¹ â†’(gâ‚â»,gâ‚‚))(m)              (def hom functor)
 = â†’(fâ‚â»,fâ‚‚) â–¹ â†’(gâ‚â»,gâ‚‚)                                (eta reduction)</code></pre>
<p>âˆ</p>
</section>
<section id="product-and-coproduct" class="Definition">
<h4><a class="anchor" href="#product-and-coproduct"></a>Definition 14.
(Product and Coproduct)</h4>
<p>A <strong>product</strong> of two objects <code>A</code> and
<code>B</code> is the object <code>C</code> equipped with two morphisms
(called projections) <code>p: C â†’ A</code> and <code>q: C â†’ B</code>
such that for any other object <code>C&#39;</code> equipped with two
projections <code>p&#39;: C&#39; â†’ A</code> and <code>q&#39;: C&#39; â†’ B</code> there is
a unique morphism <code>m: C&#39; â†’ C</code> that factorizes those
projections:</p>
<pre><code>â€ƒp&#39; = m â–¹ p
â€ƒq&#39; = m â–¹ q</code></pre>
<p>Dually, a <strong>coproduct</strong> of two objects <code>A</code>
and <code>B</code> is the object <code>C</code> equipped with two
morphisms (called injections) <code>i: A â†’ C</code> and
<code>j: B â†’ C</code> such that for any other object <code>C&#39;</code>
equipped with two injections <code>i&#39;: A â†’ C&#39;</code> and
<code>j&#39;: B â†’ C&#39;</code> there is a unique morphism
<code>m: C â†’ C&#39;</code> that factorizes those injections:</p>
<pre><code>â€ƒi&#39; = i â–¹ m
â€ƒj&#39; = j â–¹ m</code></pre>
</section>
<h2 id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
<section id="the-monoid-category" class="Example">
<h4><a class="anchor" href="#the-monoid-category"></a>Example 15. (The
Monoid Category)</h4>
<p>A monoid <code>M</code> is characterized by a set of values
<code>M</code>, an identity value <code>0</code> and an operator
<code>+ : M â†’ M â†’ M</code>, such that the following conditions are
met.</p>
<ol type="1">
<li>(Associativity) For every three values <code>x, y</code> and
<code>z</code> in <code>M</code>,
â€ƒ<code>(x + y) + z = x + (y + z)</code>.</li>
<li>(Identity) For every value <code>x</code> in <code>M</code>,
â€ƒ<code>x + 0 = x</code> â€ƒand â€ƒ<code>0 + x = x</code>.</li>
</ol>
<p>This structure forms a category with one object, named
<code>1</code>, and a morphism <code>x: 1 â†’ 1</code> for every value
<code>x</code> in <code>M</code>. Composition is defined as
â€ƒ<code>x âˆ˜ y = x + y</code>.</p>
<p><em>Proof.</em></p>
<p>(Associativity) To prove: for any morphisms <code>x, y</code>, and
<code>z</code>, â€ƒ<code>(x âˆ˜ y) âˆ˜ z = x âˆ˜ (y âˆ˜ z)</code>.</p>
<pre><code> (x âˆ˜ y) âˆ˜ z  = x + y âˆ˜ z   = (x + y) + z   (definition composition)
 x âˆ˜ (y âˆ˜ z)  = x âˆ˜ (y + z) = x + (y + z)   (definition composition)
                            = (x + y) + z   (associativity of +)</code></pre>
<p>(Identity) To prove: for any morphism <code>x</code>,
â€ƒ<code>x âˆ˜ 0 = x</code> â€ƒand â€ƒ<code>0 âˆ˜ x = x</code>.</p>
<pre><code> x âˆ˜ 0  = x + 0  (definition composition)
        = x      (definition monoid identity)
 0 âˆ˜ x  = 0 + x  (definition composition)
        = x      (definition monoid identity)</code></pre>
<p>âˆ</p>
</section>
<section id="the-category-of-categories" class="Example">
<h4><a class="anchor" href="#the-category-of-categories"></a>Example 16.
(The Category of Categories)</h4>
<p>The category <em>Cat</em> where objects are categories and morphisms
are functors between categories, is a category. Functors <code>F</code>
and <code>G</code> are composable by composing the corresponding
functions:</p>
<pre><code>â€ƒ(G â–¹ F)&lt;A&gt; = F&lt;G&lt;A&gt;&gt;
â€ƒ(G â–¹ F)(m) = F(G(m))</code></pre>
<p>Every category <code>ğ“’</code> has an identity functor <code>I</code>
to itself, which is given by</p>
<pre><code>â€ƒI: Obj(ğ“’) â†’ Obj(ğ“’), I&lt;A&gt; = A
â€ƒI: Mor(ğ“’) â†’ Mor(ğ“’), I(m) = m</code></pre>
<p><em>Proof.</em></p>
<p>(Associativity) Composing functors is associative, because composing
the underlying functions is associative. (Identity) For any object
<code>ğ“’</code> in Obj(Cat) and any functor <code>F</code> going out of
<code>ğ“’</code> and any functor <code>G</code> coming into
<code>ğ“’</code>, let <code>I</code> be the identity functor of
<code>ğ“’</code>. Then</p>
<pre><code>â€ƒF âˆ˜ I = F 
â€ƒI âˆ˜ G = G</code></pre>
<p>because the underlying functions of <code>I</code> are identity
functions. âˆ</p>
</section>
<section id="the-set-category" class="Example">
<h4><a class="anchor" href="#the-set-category"></a>Example 17. (The Set
Category)</h4>
<p>The category <em>Set</em> is the category where objects are sets and
morphisms are functions between sets. When programming with total
(non-throwing, terminating) functions, this is the category you operate
in. Types can be seen as the set of all possible values they hold, and
functions map types to other types. For example, <code>Bool</code> and
<code>Int</code> are objects, and <code>isOdd : Int â†’ Bool</code> is a
morphism.</p>
</section>
<section id="the-product-functor-in-set" class="Example">
<h4><a class="anchor" href="#the-product-functor-in-set"></a>Example 18.
(The Product Functor in Set)</h4>
<p>The type constructor</p>
<pre><code>â€ƒPair: Set â¨¯ Set â†’ Set
â€ƒPair&lt;A,B&gt; = Pair(A,B)</code></pre>
<p>forms a bifunctor under</p>
<pre><code>â€ƒPair(f,g) Pair(x,y) = Pair(f(x),g(y))</code></pre>
<p><em>Proof.</em> TODO</p>
</section>
<section id="the-sum-functor-in-set" class="Example">
<h4><a class="anchor" href="#the-sum-functor-in-set"></a>Example 19.
(The Sum Functor in Set)</h4>
<p>The type constructor</p>
<pre><code>â€ƒEither: Set â¨¯ Set â†’ Set
â€ƒEither&lt;A,B&gt; = Left(A) | Right(B)</code></pre>
<p>forms a bifunctor under</p>
<pre><code>â€ƒEither(f,g) Left(x) = Left(f(x))
â€ƒEither(f,g) Right(y) = Right(g(y))</code></pre>
<p><em>Proof.</em> TODO</p>
</section>
<section id="the-list-functor" class="Example">
<h4><a class="anchor" href="#the-list-functor"></a>Example 20. (The List
Functor)</h4>
<p>The <em>List</em> type constructor forms an endofunctor in the
category Set.</p>
<pre><code> List : Set â†’ Set
 List&lt;A&gt; = Nil | Cons(A, List&lt;A&gt;)
 List : (A â†’ B) â†’ (List&lt;A&gt; â†’ List&lt;B&gt;)
 List(f) = Nil â†¦ Nil                                 
         | Cons(x, xs) â†¦ Cons(f(x), List(f)(xs))</code></pre>
<p><em>Proof.</em></p>
<p>(Associativity) To prove: For any morphisms <code>f: A â†’ B</code> and
<code>g: B â†’ C</code>, <code>List(f â–¹ g) = List(f) â–¹ List(g)</code>. We
prove that these two expressions are the same for all possible inputs,
namely <code>Nil</code> and <code>Cons(x,xs)</code>.</p>
<p>Case <code>Nil</code>:</p>
<pre><code>List(f â–¹ g)(Nil) = Nil                           (List functor definition on Nil)
(List(f) â–¹ List(g))(Nil) = List(g)(List(f)(Nil)) (Definition composition)
                         = List(g)(Nil)          (List functor definition on Nil)
                         = Nil                   (List functor definition on Nil)</code></pre>
<p>Both expressions evaluate to <code>Nil</code>.</p>
<p>Case <code>Cons(x, xs)</code>:</p>
<pre><code>List(f â–¹ g)(Cons(x, xs)) = Cons((f â–¹ g)(x), List(f â–¹ g)(xs))     (List functor definition on Cons)
                         = Cons(g(f(x)), List(f â–¹ g)(xs)))       (Definition composition)

(List(f) â–¹ List(g))(Cons(x, xs)) = List(g)(List(f)(Cons(x, xs)))             (Definition composition)
                                 = List(g)(Cons(f(x), List(f)(xs)))          (List functor definition on Cons)
                                 = Cons(g(f(x)), List(g)(List(f)(xs)))       (List functor definition on Cons)
                                 = Cons(g(f(x)), (List(f) â–¹ List(g))(xs))    (Definition composition)
                                 = Cons(g(f(x)), (List(f â–¹ g))(xs))          (Induction)</code></pre>
<p>Both expressions simplify to
<code>Cons(g(f(x)), (List(f â–¹ g))(xs))</code>.</p>
<p>(Identity) To prove: For any object <code>A</code> in Set,
<code>List(id&lt;A&gt;) = id&lt;List&lt;A&gt;&gt;</code>.</p>
<p>Case <code>Nil</code>:</p>
<pre><code>id&lt;List&lt;A&gt;&gt;(Nil) = Nil          (Identity function on List&lt;A&gt;)
List(id&lt;A&gt;)(Nil) = Nil          (List functor definition on Nil)</code></pre>
<p>Case <code>Cons(x, xs)</code>:</p>
<pre><code>id&lt;List&lt;A&gt;&gt;(Cons(x, xs)) = Cons(x, xs)                      (Identity definition on List&lt;A&gt;)
List(id&lt;A&gt;)(Cons(x, xs)) = Cons(id&lt;A&gt;(x), List(id&lt;A&gt;)(xs))  (List functor definition on Cons)
                         = Cons(x, List(id&lt;A&gt;)(xs))         (Identity morphism definition)
                         = Cons(x, id&lt;List&lt;A&gt;&gt;(xs))         (Induction)
                         = Cons(x, xs)                      (Identity definition on List&lt;A&gt;)</code></pre>
<p>Both expressions simplify to <code>Cons(x, xs)</code>. âˆ</p>
</section>
<section id="haskell-functor" class="Example">
<h4><a class="anchor" href="#haskell-functor"></a>Example 21. (Haskell
Functor)</h4>
<p>Any Haskell type constructor <code>F</code> that has an instance of
the <a href="https://wiki.haskell.org/Functor">Haskell Functor class</a>
forms an endofunctor in Set (ignoring exceptions and
non-termination).</p>
<p><em>Proof.</em></p>
<p>We are given a type constructor <code>F</code> with one argument, and
a function <code>fmap : (a â†’ b) â†’ (F a â†’ F b)</code>, where fmap obeys
the following laws:</p>
<pre><code>â€ƒfmap id = id
â€ƒfmap (f âˆ˜ g) = fmap f âˆ˜ fmap g</code></pre>
<p>This gives us</p>
<pre><code> F : Obj(Set) â†’ Obj(Set)
 F&lt;A&gt; = F A
 F : Mor(Set) â†’ Mor(Set)
 F(f) = fmap f</code></pre>
<p>(Associativity) To prove: for any two morphisms <code>f</code> and
<code>g</code> in Set, <code>F(f âˆ˜ g) = F(f) âˆ˜ F(g)</code>.</p>
<pre><code> F(f âˆ˜ g) = fmap (f âˆ˜ g)    (definition F)
          = fmap f âˆ˜ fmap g (Haskell Functor Law)
          = F(f) âˆ˜ F(g)     (definition F)</code></pre>
<p>(Identity) To prove: for any object <code>A</code> in Set,
<code>F(id&lt;A&gt;) = id&lt;F&lt;A&gt;&gt;</code>.</p>
<pre><code> id&lt;F&lt;A&gt;&gt; = id          (definition Haskell id)
 F(id&lt;A&gt;) = fmap id&lt;A&gt;  (definition F)
          = fmap id     (definition Haskell id)
          = id          (Haskell Functor Law)</code></pre>
</section>
<!--
::: Example :::
# The PreList Bifunctor
The PreList type constructor given below forms a bifunctor from FP â¨¯ FP to FP.

â€ƒPreList : Obj~FP~ â†’ Obj~FP~ â†’ Obj~FP~
â€ƒPreList a b = Nil | Cons a b

_Proof._

Note that by uncurrying we have

â€ƒPreList : Obj~FPâ¨¯FP~ â†’ Obj~FP~.

which gives us the required object mapping.
Furthermore, define map~PreList~ : Mor~FPâ¨¯FP~ â†’ Mor~FP~ as

â€ƒmap~PreList~ (f, g) Nil = Nil
â€ƒmap~PreList~ (f, g) (Cons a b) = Cons (f a) (g b)

[lowerroman]
. To prove: for any two morphisms f and g in Mor~FPâ¨¯FP~, â€ƒmap~PreList~ (f âˆ˜ g) = map~PreList~ f âˆ˜ map~PreList~ g.

[{eqtable}]
|#
| map (f âˆ˜ g) Nil     | = Nil                | (definition map~PreList~)
| (map f âˆ˜ map g) Nil | = map f (map g Nil)  | (definition composition)
|                     | = map f Nil          | (definition map~PreList~)
|                     | = Nil                | (definition map~PreList~)
|#

[{eqtable}]
|#
| map ((f, f') âˆ˜ (g, g')) (Cons x y)    | = map (f âˆ˜ g, f' âˆ˜ g') (Cons x y)      | (definition product category)
|                                        | = Cons ((f âˆ˜ g) x) ((f' âˆ˜ g') y)       | (definition map~PreList~)
|                                        | = Cons (f (g x)) (f' (g' y))           | (definition composition)
|                                        |                                        |
| (map (f, f') âˆ˜ map (g, g')) (Cons x y) | = map (f, f') (map (g, g') (Cons x y)) | (definition composition)
|                                        | = map (f, f') (Cons (g x) (g' y))      | (definition map~PreList~)
|                                        | = Cons (f (g x)) (f' (g' y))           | (definition map~PreList~)
|#

[lowerroman,start=2]
. To prove: for any object (a, b) in Obj~FPâ¨¯FP~, â€ƒmap~PreList~ id~(a,b)~ = id~PreListÂ (a,b)~.

[{eqtable}]
|#
| map id Nil        | = Nil                 | (definition map~PreList~)
| map id (Cons x y) | = Cons (id x) (id y)  | (definition map~PreList~)
|                   | = Cons x y            | (definition id)
|#

âˆ
:::
-->
</div>
</body>
</html>
